{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is here applied to discover strain energy density functions of hyperelastic materials. Starting from a deformed body under loading (a), the point-wise displacement measurements (b) are interpolated by constructing a finite element mesh (c). The resulting continuous displacement field (d) is differentiated to obtain the strain field (e). The material strain energy density is formulated as a linear combination of a large catalogue of nonlinear features and unknown material parameters theta (f). The derivative of the strain energy density with respect to the strain field yields the stress field (g). A joint optimization problem (k) is formulated to find the unknown material parameters theta such that the weak form of the linear momentum balance in the bulk material (h) and the reaction force balance on the Dirichlet boundaries (i) are satisfied. The joint optimization problem (k) also includes a sparsity-promoting regularization (j) to yield a parsimonious and interpretable material model. About the documentation The documentation contains detailed information for the most important functions (subroutines). For each function, the input arguments and output arguments are provided. The documentation can be browsed by using the search box. The provided example helps to understand the workflow of EUCLID, it can be executed using the code and data provided on GitHub . The data used in the publication can be downloaded from the ETH Research Collection .","title":"Home"},{"location":"#about-the-documentation","text":"The documentation contains detailed information for the most important functions (subroutines). For each function, the input arguments and output arguments are provided. The documentation can be browsed by using the search box. The provided example helps to understand the workflow of EUCLID, it can be executed using the code and data provided on GitHub . The data used in the publication can be downloaded from the ETH Research Collection .","title":"About the documentation"},{"location":"code_data/","text":"Code The codes are publically available on GitHub . Data An exemplary dataset is available in the GitHub repository. The data used in the publication can be downloaded from the ETH Research Collection .","title":"Code/Data"},{"location":"code_data/#code","text":"The codes are publically available on GitHub .","title":"Code"},{"location":"code_data/#data","text":"An exemplary dataset is available in the GitHub repository. The data used in the publication can be downloaded from the ETH Research Collection .","title":"Data"},{"location":"contact/","text":"Contact Moritz Flaschel E-Mail: mflaschel@ethz.ch Web: compmech.ethz.ch Siddhant Kumar E-Mail: sid.kumar@tudelft.nl Web: mech-mat.com Laura De Lorenzis E-Mail: ldelorenzis@ethz.ch Web: compmech.ethz.ch","title":"Contact"},{"location":"contact/#contact","text":"","title":"Contact"},{"location":"contact/#moritz-flaschel","text":"E-Mail: mflaschel@ethz.ch Web: compmech.ethz.ch","title":"Moritz Flaschel"},{"location":"contact/#siddhant-kumar","text":"E-Mail: sid.kumar@tudelft.nl Web: mech-mat.com","title":"Siddhant Kumar"},{"location":"contact/#laura-de-lorenzis","text":"E-Mail: ldelorenzis@ethz.ch Web: compmech.ethz.ch","title":"Laura De Lorenzis"},{"location":"example_hyperelasticity/","text":"Example It follows a step-by-step description of the implemented algorithm for an exemplary dataset. In particular, EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is applied to displacement and reaction force data that were generated based on the Neo-Hookean material model NH2. The goal is to use the data to discover the material model, without knowing its specific mathematical form a priori. Data and Parameters The input data for EUCLID and the parameters for the optimization process are defined in config.py . First, the material model based on which the data were generated, the mesh, the load steps and the noise level are specified. str_model = 'NeoHookeanJ2' str_mesh = 'plate_hole_1k_' loadsteps = [10,20,30,40] noiseLevelData = '0' noiseLevel = 0.0001 Here, noiseLevelData is set to zero meaning that we want to load data that has not yet been corrupted by noise and noiseLevel is set to be greater than zero as artificial noise should be added to that data. We have to make sure that femDataPath describes the correct path pointing to the finite element data. Higher resolution data can be downloaded from the ETH Research Collection . After specifying which data to use, the hyperparameters for EUCLID are chosen. balance = 100 penaltyLp = 1e-4 p = 1.0/4.0 factorIncrements = 5 numGuesses = 1 threshold = 1e-2 Setting balance = 100 increases the influence of boundary data on the objective function and penaltyLp defines the initial value of the penalty factor in front of the Lp-regularization term added to the objective function. The latter parameter will be successively increased by the factor factorIncrements until a physically admissible material model is found. For this example, we choose only one initial guess for the minimization probem and the threshold below which material parameters should be discarded is defined as threshold = 1e-2 . Discovery Executing main_Lp.py starts the material model discovery process. The parameters defined in config.py are loaded as import config as c . A loop over all load steps is defined and for each load step, the finite element data is loaded and perturbed by the specified noise. for loadstep in c.loadsteps: data = loadFemData(c.femDataPath+'/'+str(loadstep), AD=True, noiseLevel = c.noiseLevel, noiseType = 'displacement') datasets.append(data) The left hand side LHS and right hand side RHS of the system of linear equations, which are obtained from differentiating the minimization function (without Lp-regularization), are assembled. Finally, the material model is discovered from the data by executing: theta = applyPenaltyLpIteration(datasets,LHS,RHS,c) Results In applyPenaltyLpIteration the fixed-point iteration is applied for the initial penalty factor in front of the sparsity promoting Lp-regularization term. As the initial value has been choosen negligibly small, the obtained solution vector for the material parameters theta is dense, i.e., it contains a large number of nonzero entries. ----------------------------------------------------- Apply Lp-norm penalty. Lp-norm penalty factor: 0.0001 Lp-norm: p= 0.25 Number of initial guesses: 1 Solution with the lowest cost: [ 6.08591003e-01 -1.26556172e+01 -1.50304242e+00 3.47039792e+00 0.00000000e+00 -8.40926870e-01 4.26303110e+00 -6.44342608e+00 2.68558116e+00 1.91942291e-01 -5.80249192e-01 0.00000000e+00 1.13330467e+00 -7.01748020e-01 -8.85663806e-03 0.00000000e+00 7.39918129e-02 -4.10729435e-02 -1.23457739e-01 9.60345278e-02 0.00000000e+00 9.97033677e-04 0.00000000e+00 -1.09769271e-02 1.66016891e-02 -3.06059710e-03 -3.42983131e-03 -1.06609625e-05 7.32603777e-05 -1.98700714e-04 0.00000000e+00 1.03872040e-03 -1.85894059e-03 1.16813894e-03 -2.13678851e-04 1.50478155e+00 0.00000000e+00 -1.44416532e-01 7.52157815e-01 -1.03935826e+00 5.20008688e-01 -8.75636549e-02 3.75995295e+01] ----------------------------------------------------- Such a solution is not desired as the resulting material model would have many material parameters and would be physically uninterpretable. Further, the resulting model shown above is not physically admissible, which can be proven by calculating the strain energy density along specific deformation paths (see model_requirements.py ). Hence, in applyPenaltyLpIteration the penalty factor penaltyLp is successively increased until the physical requirements are fulfilled. This procedure finally results in: ----------------------------------------------------- Apply Lp-norm penalty. Lp-norm penalty factor: 0.0125 Lp-norm: p= 0.25 Number of initial guesses: 1 Solution with the lowest cost: [ 4.97871855e-01 -5.74695560e-05 0.00000000e+00 0.00000000e+00 0.00000000e+00 7.35505936e-05 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -7.84065373e-06 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.49898747e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00] ----------------------------------------------------- It can be seen that the material parameters have been shrunk, and the physical requirements are now fulfilled. After a final postprocessing step, in which parameters with absolute value below a threshold are set to zero, a sparse material parameter vector is found. ----------------------------------------------------- Apply threshold: 0.01 Converged after iteration: 1 Solution: [0.50052861 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.49892849 0. 0. 0. 0. 0. 0. 0. ] ----------------------------------------------------- The resulting material model has hence a small amount of material parameters and is physically interpretable. It is observed that EUCLID identifies the correct features of the Neo-Hookean material model. The material parameter values vary only slightly compared to the true parameters as a consequence of the noise added to the displacement data.","title":"Example"},{"location":"example_hyperelasticity/#example","text":"It follows a step-by-step description of the implemented algorithm for an exemplary dataset. In particular, EUCLID (Efficient Unsupervised Constitutive Law Identification & Discovery) is applied to displacement and reaction force data that were generated based on the Neo-Hookean material model NH2. The goal is to use the data to discover the material model, without knowing its specific mathematical form a priori.","title":"Example"},{"location":"example_hyperelasticity/#data-and-parameters","text":"The input data for EUCLID and the parameters for the optimization process are defined in config.py . First, the material model based on which the data were generated, the mesh, the load steps and the noise level are specified. str_model = 'NeoHookeanJ2' str_mesh = 'plate_hole_1k_' loadsteps = [10,20,30,40] noiseLevelData = '0' noiseLevel = 0.0001 Here, noiseLevelData is set to zero meaning that we want to load data that has not yet been corrupted by noise and noiseLevel is set to be greater than zero as artificial noise should be added to that data. We have to make sure that femDataPath describes the correct path pointing to the finite element data. Higher resolution data can be downloaded from the ETH Research Collection . After specifying which data to use, the hyperparameters for EUCLID are chosen. balance = 100 penaltyLp = 1e-4 p = 1.0/4.0 factorIncrements = 5 numGuesses = 1 threshold = 1e-2 Setting balance = 100 increases the influence of boundary data on the objective function and penaltyLp defines the initial value of the penalty factor in front of the Lp-regularization term added to the objective function. The latter parameter will be successively increased by the factor factorIncrements until a physically admissible material model is found. For this example, we choose only one initial guess for the minimization probem and the threshold below which material parameters should be discarded is defined as threshold = 1e-2 .","title":"Data and Parameters"},{"location":"example_hyperelasticity/#discovery","text":"Executing main_Lp.py starts the material model discovery process. The parameters defined in config.py are loaded as import config as c . A loop over all load steps is defined and for each load step, the finite element data is loaded and perturbed by the specified noise. for loadstep in c.loadsteps: data = loadFemData(c.femDataPath+'/'+str(loadstep), AD=True, noiseLevel = c.noiseLevel, noiseType = 'displacement') datasets.append(data) The left hand side LHS and right hand side RHS of the system of linear equations, which are obtained from differentiating the minimization function (without Lp-regularization), are assembled. Finally, the material model is discovered from the data by executing: theta = applyPenaltyLpIteration(datasets,LHS,RHS,c)","title":"Discovery"},{"location":"example_hyperelasticity/#results","text":"In applyPenaltyLpIteration the fixed-point iteration is applied for the initial penalty factor in front of the sparsity promoting Lp-regularization term. As the initial value has been choosen negligibly small, the obtained solution vector for the material parameters theta is dense, i.e., it contains a large number of nonzero entries. ----------------------------------------------------- Apply Lp-norm penalty. Lp-norm penalty factor: 0.0001 Lp-norm: p= 0.25 Number of initial guesses: 1 Solution with the lowest cost: [ 6.08591003e-01 -1.26556172e+01 -1.50304242e+00 3.47039792e+00 0.00000000e+00 -8.40926870e-01 4.26303110e+00 -6.44342608e+00 2.68558116e+00 1.91942291e-01 -5.80249192e-01 0.00000000e+00 1.13330467e+00 -7.01748020e-01 -8.85663806e-03 0.00000000e+00 7.39918129e-02 -4.10729435e-02 -1.23457739e-01 9.60345278e-02 0.00000000e+00 9.97033677e-04 0.00000000e+00 -1.09769271e-02 1.66016891e-02 -3.06059710e-03 -3.42983131e-03 -1.06609625e-05 7.32603777e-05 -1.98700714e-04 0.00000000e+00 1.03872040e-03 -1.85894059e-03 1.16813894e-03 -2.13678851e-04 1.50478155e+00 0.00000000e+00 -1.44416532e-01 7.52157815e-01 -1.03935826e+00 5.20008688e-01 -8.75636549e-02 3.75995295e+01] ----------------------------------------------------- Such a solution is not desired as the resulting material model would have many material parameters and would be physically uninterpretable. Further, the resulting model shown above is not physically admissible, which can be proven by calculating the strain energy density along specific deformation paths (see model_requirements.py ). Hence, in applyPenaltyLpIteration the penalty factor penaltyLp is successively increased until the physical requirements are fulfilled. This procedure finally results in: ----------------------------------------------------- Apply Lp-norm penalty. Lp-norm penalty factor: 0.0125 Lp-norm: p= 0.25 Number of initial guesses: 1 Solution with the lowest cost: [ 4.97871855e-01 -5.74695560e-05 0.00000000e+00 0.00000000e+00 0.00000000e+00 7.35505936e-05 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 -7.84065373e-06 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 1.49898747e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00 0.00000000e+00] ----------------------------------------------------- It can be seen that the material parameters have been shrunk, and the physical requirements are now fulfilled. After a final postprocessing step, in which parameters with absolute value below a threshold are set to zero, a sparse material parameter vector is found. ----------------------------------------------------- Apply threshold: 0.01 Converged after iteration: 1 Solution: [0.50052861 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1.49892849 0. 0. 0. 0. 0. 0. 0. ] ----------------------------------------------------- The resulting material model has hence a small amount of material parameters and is physically interpretable. It is observed that EUCLID identifies the correct features of the Neo-Hookean material model. The material parameter values vary only slightly compared to the true parameters as a consequence of the noise added to the displacement data.","title":"Results"},{"location":"publication/","text":"This browser does not support PDFs. Please download the PDF to view it: Download PDF .","title":"Publication"},{"location":"code/config/","text":"config Provide elementary configurations. Import this by adding import config as c to the main executable file. Please make sure that the correct path to the finite element data is specified.","title":"config"},{"location":"code/config/#config","text":"Provide elementary configurations. Import this by adding import config as c to the main executable file. Please make sure that the correct path to the finite element data is specified.","title":"config"},{"location":"code/dataDefinitions/","text":"class Reaction: Attributes force - scalar force value dofs - degrees of freedom corresponding to the reaction force Methods __init__(...): - Generate Reaction object. class FeatureSet: Attributes features d_features_dI1 - derivative d_features_dI2 - derivative d_features_dI3 - derivative Methods __init__(...): - Generate FeatureSet object. convertTensorToNumpy(...): - Convert to numpy. convertToNumpy(...): - Convert to numpy. class FemDataset: Attributes path numNodes - number of nodes x_nodes - node reference positions u_nodes - node displacements dirichlet_nodes - Dirichlet nodes reactions numElements - number of finite elements qpWeights - weights of the quadrature points connectivity - contains connectivity information of the elements gradNa - shape function gradient F - deformation gradient in Voigt notation J - Jacobian C - Cauchy-Green strain tensor in Voigt notation I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant dI1dF - derivative dI2dF - derivative dI3dF - derivative featureSet Methods __init__(...): - Generate FemDataset object. convertTensorToNumpy(...): - Convert to numpy. convertToNumpy(...): - Convert to numpy.","title":"dataDefinitions"},{"location":"code/dataDefinitions/#class-reaction","text":"Attributes force - scalar force value dofs - degrees of freedom corresponding to the reaction force Methods __init__(...): - Generate Reaction object.","title":"class Reaction:"},{"location":"code/dataDefinitions/#class-featureset","text":"Attributes features d_features_dI1 - derivative d_features_dI2 - derivative d_features_dI3 - derivative Methods __init__(...): - Generate FeatureSet object. convertTensorToNumpy(...): - Convert to numpy. convertToNumpy(...): - Convert to numpy.","title":"class FeatureSet:"},{"location":"code/dataDefinitions/#class-femdataset","text":"Attributes path numNodes - number of nodes x_nodes - node reference positions u_nodes - node displacements dirichlet_nodes - Dirichlet nodes reactions numElements - number of finite elements qpWeights - weights of the quadrature points connectivity - contains connectivity information of the elements gradNa - shape function gradient F - deformation gradient in Voigt notation J - Jacobian C - Cauchy-Green strain tensor in Voigt notation I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant dI1dF - derivative dI2dF - derivative dI3dF - derivative featureSet Methods __init__(...): - Generate FemDataset object. convertTensorToNumpy(...): - Convert to numpy. convertToNumpy(...): - Convert to numpy.","title":"class FemDataset:"},{"location":"code/features/","text":"computeFeatures(I1, I2, I3): Compute the features dependent on the right Cauchy-Green strain invariants. Note that the features only depend on I1 and I3. Input Arguments I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant Output Arguments x - features getNumberOfFeatures(): Compute number of features. Input Arguments none Output Arguments features.shape[1] - number of features","title":"features"},{"location":"code/features/#computefeaturesi1-i2-i3","text":"Compute the features dependent on the right Cauchy-Green strain invariants. Note that the features only depend on I1 and I3. Input Arguments I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant Output Arguments x - features","title":"computeFeatures(I1, I2, I3):"},{"location":"code/features/#getnumberoffeatures","text":"Compute number of features. Input Arguments none Output Arguments features.shape[1] - number of features","title":"getNumberOfFeatures():"},{"location":"code/helper/","text":"initCUDA(cudaID): Setup GPU-CUDA acceleration. Input Arguments cudaID - -1: CPU, 0: CUDA0, 1: CUDA1 Output Arguments none","title":"helper"},{"location":"code/helper/#initcudacudaid","text":"Setup GPU-CUDA acceleration. Input Arguments cudaID - -1: CPU, 0: CUDA0, 1: CUDA1 Output Arguments none","title":"initCUDA(cudaID):"},{"location":"code/loadFemData/","text":"loadFemData(path, AD = True, noiseLevel = 0., noiseType = 'displacement', denoisedDisplacements = None): Load finite element data and add noise (optional). Note that the loaded finite element data might already be perturbed by noise. In that case, adding additional noise is not necessary. Input Arguments path - path to finite element data AD - specify if automatic differention is needed noiseLevel - noise level noiseType - specify whether noise should be added to displacements or strains denoisedDisplacements - pass denoised displacement data if available Output Arguments dataset - finite element dataset","title":"loadFemData"},{"location":"code/loadFemData/#loadfemdatapath-ad-true-noiselevel-0-noisetype-displacement-denoiseddisplacements-none","text":"Load finite element data and add noise (optional). Note that the loaded finite element data might already be perturbed by noise. In that case, adding additional noise is not necessary. Input Arguments path - path to finite element data AD - specify if automatic differention is needed noiseLevel - noise level noiseType - specify whether noise should be added to displacements or strains denoisedDisplacements - pass denoised displacement data if available Output Arguments dataset - finite element dataset","title":"loadFemData(path, AD = True, noiseLevel = 0., noiseType = 'displacement', denoisedDisplacements = None):"},{"location":"code/main/","text":"main Load a finite element dataset and apply EUCLID to discover a constitutive law, i.e., the hyperelastic strain energy density, as a compact mathematical expression.","title":"main"},{"location":"code/main/#main","text":"Load a finite element dataset and apply EUCLID to discover a constitutive law, i.e., the hyperelastic strain energy density, as a compact mathematical expression.","title":"main"},{"location":"code/models/","text":"applyThreshold(LHS,RHS,theta,c): Apply the threshold algorithm to the given linear system to enforce sparsity on the solution vector theta. Input Arguments LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system theta - material parameters c - see config Output Arguments theta - material parameters computeDoubleContraction(A,B): Double contraction in Voigt notation. Input Arguments A - vector containing components of a 2x2 matrix ([A_11 A_12 A_21 A_22]) B - vector containing components of a 2x2 matrix ([B_11 B_12 B_21 B_22]) Output Arguments C - scalar value of the double contraction computeLpNorm(vector,p): Compute the Lp-regularization term for a given vector. Input Arguments vector p - type of the Lp-regularization term Output Arguments norm","title":"models"},{"location":"code/models/#applythresholdlhsrhsthetac","text":"Apply the threshold algorithm to the given linear system to enforce sparsity on the solution vector theta. Input Arguments LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system theta - material parameters c - see config Output Arguments theta - material parameters","title":"applyThreshold(LHS,RHS,theta,c):"},{"location":"code/models/#computedoublecontractionab","text":"Double contraction in Voigt notation. Input Arguments A - vector containing components of a 2x2 matrix ([A_11 A_12 A_21 A_22]) B - vector containing components of a 2x2 matrix ([B_11 B_12 B_21 B_22]) Output Arguments C - scalar value of the double contraction","title":"computeDoubleContraction(A,B):"},{"location":"code/models/#computelpnormvectorp","text":"Compute the Lp-regularization term for a given vector. Input Arguments vector p - type of the Lp-regularization term Output Arguments norm","title":"computeLpNorm(vector,p):"},{"location":"code/models_Lp/","text":"applyPenaltyLpIteration(datasets,LHS,RHS,c): Start with a small penalty parameter and solve the Lp-regularized optimization problem, increase the penalty parameter until physical requirements are fulfilled. Input Arguments datasets LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system c - see config Output Arguments theta - material parameters applyPenaltyLpRandomStart(datasets,LHS,RHS,c): Solve the Lp-regularized optimization problem with random initial guesses. Input Arguments datasets LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system c - see config Output Arguments theta - material parameters at_least_one_converged - information about the convergence applyPenaltyLpThreshold(datasets,LHS,RHS,theta,c): Solve the Lp-regularized optimization problem for a given initial guess using fixed-point iteration. During the iterative process, the threshold algorithm is applied. Input Arguments datasets LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system theta - initial guess of material parameters c - see config Output Arguments theta - material parameters converged - information about the convergence checkLocalMinimumLp(datasets,theta,c): Check if the provided solution is a local minimum of the cost function. Input Arguments datasets theta - material parameters c - see config Output Arguments none computeCostLp(datasets,theta,c): Compute cost function for L2 minimization with Lp-regularization. Input Arguments datasets theta - material parameters c - see config Output Arguments Cost_weak - cost corresponding to the weak linear momentum balance Cost_penaltyLp - cost corresponding to the Lp-regularization Cost_total - total cost saveResultsLp(theta,c,counter_load=None): Save the results and the chosen parameters in a text file. Input Arguments theta - material parameters c - see config counter_load - current load step Output Arguments none","title":"models_Lp"},{"location":"code/models_Lp/#applypenaltylpiterationdatasetslhsrhsc","text":"Start with a small penalty parameter and solve the Lp-regularized optimization problem, increase the penalty parameter until physical requirements are fulfilled. Input Arguments datasets LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system c - see config Output Arguments theta - material parameters","title":"applyPenaltyLpIteration(datasets,LHS,RHS,c):"},{"location":"code/models_Lp/#applypenaltylprandomstartdatasetslhsrhsc","text":"Solve the Lp-regularized optimization problem with random initial guesses. Input Arguments datasets LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system c - see config Output Arguments theta - material parameters at_least_one_converged - information about the convergence","title":"applyPenaltyLpRandomStart(datasets,LHS,RHS,c):"},{"location":"code/models_Lp/#applypenaltylpthresholddatasetslhsrhsthetac","text":"Solve the Lp-regularized optimization problem for a given initial guess using fixed-point iteration. During the iterative process, the threshold algorithm is applied. Input Arguments datasets LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system theta - initial guess of material parameters c - see config Output Arguments theta - material parameters converged - information about the convergence","title":"applyPenaltyLpThreshold(datasets,LHS,RHS,theta,c):"},{"location":"code/models_Lp/#checklocalminimumlpdatasetsthetac","text":"Check if the provided solution is a local minimum of the cost function. Input Arguments datasets theta - material parameters c - see config Output Arguments none","title":"checkLocalMinimumLp(datasets,theta,c):"},{"location":"code/models_Lp/#computecostlpdatasetsthetac","text":"Compute cost function for L2 minimization with Lp-regularization. Input Arguments datasets theta - material parameters c - see config Output Arguments Cost_weak - cost corresponding to the weak linear momentum balance Cost_penaltyLp - cost corresponding to the Lp-regularization Cost_total - total cost","title":"computeCostLp(datasets,theta,c):"},{"location":"code/models_Lp/#saveresultslpthetaccounter_loadnone","text":"Save the results and the chosen parameters in a text file. Input Arguments theta - material parameters c - see config counter_load - current load step Output Arguments none","title":"saveResultsLp(theta,c,counter_load=None):"},{"location":"code/models_requirements/","text":"checkEnergyRequirementsRigorous(datasets,theta): Check if physical requirements are fulfilled. Input Arguments datasets theta - material parameters Output Arguments fulfillEnergyRequirements - specify if the physical requirements are fulfilled computeFeaturesGivenDeformation(deformationPath,x): Compute features for given deformation. Input Arguments deformationPath - type of deformation x - scalar deformation measure Output Arguments Q - features getPathX(): Generate a scalar deformation path. Input Arguments none Output Arguments pathx - scalar deformation path","title":"models_requirements"},{"location":"code/models_requirements/#checkenergyrequirementsrigorousdatasetstheta","text":"Check if physical requirements are fulfilled. Input Arguments datasets theta - material parameters Output Arguments fulfillEnergyRequirements - specify if the physical requirements are fulfilled","title":"checkEnergyRequirementsRigorous(datasets,theta):"},{"location":"code/models_requirements/#computefeaturesgivendeformationdeformationpathx","text":"Compute features for given deformation. Input Arguments deformationPath - type of deformation x - scalar deformation measure Output Arguments Q - features","title":"computeFeaturesGivenDeformation(deformationPath,x):"},{"location":"code/models_requirements/#getpathx","text":"Generate a scalar deformation path. Input Arguments none Output Arguments pathx - scalar deformation path","title":"getPathX():"},{"location":"code/models_weak/","text":"assembleB(data,ele,c): Define a matrix (B-matrix) such that the gradient of the test functions can be expressed as a product of the B-matrix and the nodal values of the test functions. Input Arguments data ele - element number c - see config Output Arguments B_element - B-matrix assembleFeatureDerivative(data,ele): Apply chain rule to calculate feature derivatives at element level. Input Arguments data ele - element number Output Arguments d_features_dF_element - derivative at element level assembleGlobalMatrix(matrix_global,matrix_element,connectivity,ele,c): Add a matrix defined at an element to the corresponding position in the global matrix. Input Arguments matrix_global - global matrix matrix_element - matrix at element level connectivity - contains connectivity information of the elements ele - element number c - see config Output Arguments matrix_global - updated global matrix assembleGlobalVector(vector_global,vector_element,connectivity,ele,c): Add a vector defined at an element to the corresponding position in the global vector. Input Arguments vector_global - global vector vector_element - vector at element level connectivity - contains connectivity information of the elements ele - element number c - see config Output Arguments vector_global - updated global vector computeInternalForceTheta(data,theta,c): Compute nodal internal forces for given material parameters. Input Arguments data theta - material parameters c - see config Output Arguments f_int_nodes - internal force at each node computeStrainEnergyTheta(data,theta): Compute strain energy density for given material parameters. Input Arguments data theta - material parameters Output Arguments Psi - strain energy density at each element Psi_total - total strain energy density computeWeakLHS(data,c): Compute left hand side of overdetermined linear system for given data. Reaction forces are not consider yet. Input Arguments data c - see config Output Arguments LHS - left hand side of overdetermined linear system computeWeakOverdetermined(data,c): Compute left and right hand side of the internal-external force balance (weak formulation) at all free and fixed degrees of freedom. Input Arguments data c - see config Output Arguments LHS_free - left hand side of non-symmetric linear system RHS_free - right hand side of non-symmetric linear system LHS_fix - left hand side of non-symmetric linear system RHS_fix - right hand side of non-symmetric linear system considerReactionGlobal(data,LHS,c): Given overdetermined linear system, add information from global reaction forces. Input Arguments data LHS - left hand side of symmetric linear system c - see config Output Arguments LHS - updated left hand side of symmetric linear system RHS - right hand side of symmetric linear system extendLHSRHS(data,c,LHS,RHS): Given symmetric linear system, add information from additional data. Input Arguments data c - see config LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system Output Arguments LHS - updated left hand side of symmetric linear system RHS - updated right hand side of symmetric linear system zipper(matrix): Take a Nx2 matrix and assemble a 2Nx1 vector of the same type. Input Arguments matrix Output Arguments vector","title":"models_weak"},{"location":"code/models_weak/#assemblebdataelec","text":"Define a matrix (B-matrix) such that the gradient of the test functions can be expressed as a product of the B-matrix and the nodal values of the test functions. Input Arguments data ele - element number c - see config Output Arguments B_element - B-matrix","title":"assembleB(data,ele,c):"},{"location":"code/models_weak/#assemblefeaturederivativedataele","text":"Apply chain rule to calculate feature derivatives at element level. Input Arguments data ele - element number Output Arguments d_features_dF_element - derivative at element level","title":"assembleFeatureDerivative(data,ele):"},{"location":"code/models_weak/#assembleglobalmatrixmatrix_globalmatrix_elementconnectivityelec","text":"Add a matrix defined at an element to the corresponding position in the global matrix. Input Arguments matrix_global - global matrix matrix_element - matrix at element level connectivity - contains connectivity information of the elements ele - element number c - see config Output Arguments matrix_global - updated global matrix","title":"assembleGlobalMatrix(matrix_global,matrix_element,connectivity,ele,c):"},{"location":"code/models_weak/#assembleglobalvectorvector_globalvector_elementconnectivityelec","text":"Add a vector defined at an element to the corresponding position in the global vector. Input Arguments vector_global - global vector vector_element - vector at element level connectivity - contains connectivity information of the elements ele - element number c - see config Output Arguments vector_global - updated global vector","title":"assembleGlobalVector(vector_global,vector_element,connectivity,ele,c):"},{"location":"code/models_weak/#computeinternalforcethetadatathetac","text":"Compute nodal internal forces for given material parameters. Input Arguments data theta - material parameters c - see config Output Arguments f_int_nodes - internal force at each node","title":"computeInternalForceTheta(data,theta,c):"},{"location":"code/models_weak/#computestrainenergythetadatatheta","text":"Compute strain energy density for given material parameters. Input Arguments data theta - material parameters Output Arguments Psi - strain energy density at each element Psi_total - total strain energy density","title":"computeStrainEnergyTheta(data,theta):"},{"location":"code/models_weak/#computeweaklhsdatac","text":"Compute left hand side of overdetermined linear system for given data. Reaction forces are not consider yet. Input Arguments data c - see config Output Arguments LHS - left hand side of overdetermined linear system","title":"computeWeakLHS(data,c):"},{"location":"code/models_weak/#computeweakoverdetermineddatac","text":"Compute left and right hand side of the internal-external force balance (weak formulation) at all free and fixed degrees of freedom. Input Arguments data c - see config Output Arguments LHS_free - left hand side of non-symmetric linear system RHS_free - right hand side of non-symmetric linear system LHS_fix - left hand side of non-symmetric linear system RHS_fix - right hand side of non-symmetric linear system","title":"computeWeakOverdetermined(data,c):"},{"location":"code/models_weak/#considerreactionglobaldatalhsc","text":"Given overdetermined linear system, add information from global reaction forces. Input Arguments data LHS - left hand side of symmetric linear system c - see config Output Arguments LHS - updated left hand side of symmetric linear system RHS - right hand side of symmetric linear system","title":"considerReactionGlobal(data,LHS,c):"},{"location":"code/models_weak/#extendlhsrhsdataclhsrhs","text":"Given symmetric linear system, add information from additional data. Input Arguments data c - see config LHS - left hand side of symmetric linear system RHS - right hand side of symmetric linear system Output Arguments LHS - updated left hand side of symmetric linear system RHS - updated right hand side of symmetric linear system","title":"extendLHSRHS(data,c,LHS,RHS):"},{"location":"code/models_weak/#zippermatrix","text":"Take a Nx2 matrix and assemble a 2Nx1 vector of the same type. Input Arguments matrix Output Arguments vector","title":"zipper(matrix):"},{"location":"code/utilities/","text":"computeCauchyGreenStrain(F): Compute right Cauchy-Green strain tensor from deformation gradient. Input Arguments F - deformation gradient in Voigt notation Output Arguments C - Cauchy-Green strain tensor in Voigt notation computeJacobian(F): Compute Jacobian from deformation gradient. Input Arguments F - deformation gradient in Voigt notation Output Arguments J - Jacobian computeStrainInvariantDerivatives(F,i,secondDerivative=False): Compute derivatives of the invariants of the Cauchy-Green strain tensor with respect to the deformation gradient. Plane strain is assumed. Input Arguments F - deformation gradient in Voigt notation i - specify the invariant that should be differentiated secondDerivative - specify if second derivative should be computed Output Arguments dIdF - derivative (note that the size of dIdF depends on the choice of secondDerivative ) computeStrainInvariants(C): Compute invariants of the Cauchy-Green strain tensor. Plane strain is assumed. Input Arguments C - Cauchy-Green strain tensor in Voigt notation Output Arguments I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant","title":"utilities"},{"location":"code/utilities/#computecauchygreenstrainf","text":"Compute right Cauchy-Green strain tensor from deformation gradient. Input Arguments F - deformation gradient in Voigt notation Output Arguments C - Cauchy-Green strain tensor in Voigt notation","title":"computeCauchyGreenStrain(F):"},{"location":"code/utilities/#computejacobianf","text":"Compute Jacobian from deformation gradient. Input Arguments F - deformation gradient in Voigt notation Output Arguments J - Jacobian","title":"computeJacobian(F):"},{"location":"code/utilities/#computestraininvariantderivativesfisecondderivativefalse","text":"Compute derivatives of the invariants of the Cauchy-Green strain tensor with respect to the deformation gradient. Plane strain is assumed. Input Arguments F - deformation gradient in Voigt notation i - specify the invariant that should be differentiated secondDerivative - specify if second derivative should be computed Output Arguments dIdF - derivative (note that the size of dIdF depends on the choice of secondDerivative )","title":"computeStrainInvariantDerivatives(F,i,secondDerivative=False):"},{"location":"code/utilities/#computestraininvariantsc","text":"Compute invariants of the Cauchy-Green strain tensor. Plane strain is assumed. Input Arguments C - Cauchy-Green strain tensor in Voigt notation Output Arguments I1 - 1st invariant I2 - 2nd invariant I3 - 3rd invariant","title":"computeStrainInvariants(C):"}]}